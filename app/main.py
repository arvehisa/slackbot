import os
import re

from slack_bolt import App
from slack_bolt.adapter.aws_lambda import SlackRequestHandler
from slack_sdk import WebClient
from slack_bolt.adapter.socket_mode import SocketModeHandler

from langchain.chat_models import BedrockChat
from langchain.embeddings import BedrockEmbeddings

from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate
from langchain.vectorstores.pgvector import PGVector

from langchain.document_loaders import WebBaseLoader
from langchain.chains.llm import LLMChain
from langchain.chains.summarize import load_summarize_chain
from langchain.chains.combine_documents.stuff import StuffDocumentsChain
from aws_lambda_powertools import Tracer


# model setting
region="us-east-1"
model_id ="anthropic.claude-v2" #anthropic.claude-v2
llm = BedrockChat(model_id=model_id, region_name=region)  
embeddings = BedrockEmbeddings(model_id="amazon.titan-embed-text-v1", region_name=region)

CONNECTION_STRING = PGVector.connection_string_from_db_params(
    driver="psycopg2",
    host=os.environ.get("PGVECTOR_HOST"),
    port="5432",
    database="postgres",
    user="postgres",
    password=os.environ.get("PGVECTOR_PASSWORD"),
)

COLLECTION_NAME = "bedrock_documents"

vectorstore = PGVector(
    collection_name=COLLECTION_NAME,
    connection_string=CONNECTION_STRING,
    embedding_function=embeddings,
)

#rag
rag_prompt_template = """
Human: Use the following pieces of context to provide a concise answer to the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.
<context>
{context}
</context

Question: {question}

Assistant:"""

RAG_PROMPT = PromptTemplate(
    template=rag_prompt_template, input_variables=["context", "question"]
)

qa = RetrievalQA.from_chain_type(
    llm=llm,
    chain_type="stuff",
    retriever=vectorstore.as_retriever(),
    return_source_documents=True,
    chain_type_kwargs={"prompt": RAG_PROMPT},
)

#url summary
def summarization(url: str):
    loader = WebBaseLoader(url)
    summarize_prompt_template ="""
    Human: Write a summary of the following in natural and fluent Japanese:
    "{text}"

    Assistant: SUMMARY:"""

    SUMMARIZE_PROMPT = PromptTemplate.from_template(summarize_prompt_template)
    llm_chain = LLMChain(llm=llm, prompt=SUMMARIZE_PROMPT)
    stuff_chain = StuffDocumentsChain(llm_chain=llm_chain, document_variable_name="text")

    docs = loader.load()
    return stuff_chain.run(docs)

# Slackbot
SLACK_BOT_TOKEN = os.environ['SLACK_BOT_TOKEN']
SOCKET_MODE_TOKEN = os.environ['SOCKET_MODE_TOKEN']
SLACK_SIGNING_SECRET = os.environ['SLACK_SIGNING_SECRET']
app = App(
        token=SLACK_BOT_TOKEN,
        process_before_response=True)

# lambda powertool tracer
tracer = Tracer()

# just ack to avoid slack 3 sec timeout
@tracer.capture_method
def just_ack(ack):
    ack()

# reaction and llm response
@tracer.capture_method
def mention(event, client, say):
    thread_ts = event['ts']
    no_mention_text = re.sub(r'^<.*>', '', event['text']) # remove content in <>
    match = re.findall(r'<(https?:\/\/[^>]+)>', event['text']) # extract url from text

    #add stamp
    try: 
        client.reactions_add(
            channel=event['channel'],
            timestamp = event['ts'],
            name = "thinking_face",
        )
    except Exception as e:
        say(text=f"reaction error: {e}", thread_ts=thread_ts)

    if no_mention_text.startswith("/rag"):
        # llm response
        result = qa({"query":no_mention_text})
        answer = result["result"]
    elif match:
        url = match[0]
        answer = summarization(url)
    else:
        answer = llm.predict(no_mention_text)
    response = f""" {answer}\n\ngenerated by {model_id}"""
    say(text=response, thread_ts=thread_ts)

# lazy listener
app.event("app_mention")(
    ack=just_ack, 
    lazy=[mention]
    )

@tracer.capture_lambda_handler
def lambda_handler(event, context):
    receiver = SlackRequestHandler(app=app)
    return receiver.handle(event, context)

# # Socket Mode
# if __name__ == "__main__":
#     handler = SocketModeHandler(app, SOCKET_MODE_TOKEN)
#     handler.start()
p